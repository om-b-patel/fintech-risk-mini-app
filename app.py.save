import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import sqlite3
from datetime import datetime


def log_usage() -> None:
    """
    Log each execution of the app to a local SQLite database.  A table named
    `usage_log` will be created if it does not already exist.  Each call
    inserts the current UTC timestamp.
    """
    conn = sqlite3.connect("metrics.db")
    cur = conn.cursor()
    cur.execute(
        "CREATE TABLE IF NOT EXISTS usage_log (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp TEXT)"
    )
    cur.execute(
        "INSERT INTO usage_log (timestamp) VALUES (?)", (datetime.utcnow().isoformat(),)
    )
    conn.commit()
    conn.close()


def download_data(ticker: str) -> pd.DataFrame:
    """
    Download one year of historical price data for a given ticker using yfinance.
    Returns an empty DataFrame if the download fails.
    """
    try:
        data = yf.download(ticker, period="1y")
    except Exception:
        return pd.DataFrame()
    return data


def compute_sma_signals(prices: pd.Series, short_window: int = 20, long_window: int = 50) -> pd.DataFrame:
    """
    Compute simple moving average (SMA) crossover signals.

    Parameters:
        prices: Series of closing prices.
        short_window: Lookback period for the short moving average.
        long_window: Lookback period for the long moving average.

    Returns a DataFrame with the short and long moving averages, the raw signal (1=long, 0=flat),
    and the position changes.
    """
    signals = pd.DataFrame(index=prices.index)
    signals["Short"] = prices.rolling(window=short_window).mean()
    signals["Long"] = prices.rolling(window=long_window).mean()
    signals["Signal"] = 0.0
    signals["Signal"][long_window:] = np.where(
        signals["Short"][long_window:] > signals["Long"][long_window:], 1.0, 0.0
    )
    signals["Positions"] = signals["Signal"].diff()
    return signals


def compute_performance(returns: pd.Series, signals: pd.Series) -> dict:n
    """n
    Compute annualized return, volatility, and Sharpe ratio for a strategy defined by signals.n
    Ensures scalar (float) metrics even if inputs come in as pandas objects.n
    """n
    # Align indexes and coerce to floatn
    signals = signals.reindex(returns.index).fillna(0).astype(float)n
    strat_returns = (returns.astype(float) * signals.shift(1).fillna(0)).dropna()n
n
    if strat_returns.empty:n
        return {"ann_return": 0.0, "ann_vol": 0.0, "sharpe": 0.0}n
n
    daily_mean = float(strat_returns.mean())n
    daily_std = float(strat_returns.std())n
n
    ann_return = float((1.0 + daily_mean) ** 252 - 1.0)n
    ann_vol = float(daily_std * np.sqrt(252))n
    sharpe = float(ann_return / ann_vol) if ann_vol != 0.0 else 0.0n
n
    return {"ann_return": ann_return, "ann_vol": ann_vol, "sharpe": sharpe}n
    Parameters:
        returns: Daily returns of the underlying asset.
        signals: Series of 1/0 values indicating when the strategy is invested.

    Returns:
        A dict containing the keys 'ann_return', 'ann_vol', and 'sharpe'.
    """
    strat_returns = returns * signals.shift(1).fillna(0)
    ann_return = (1 + strat_returns.mean()) ** 252 - 1
    ann_vol = strat_returns.std() * np.sqrt(252)
    sharpe = ann_return / ann_vol if ann_vol != 0 else 0
    return {
        "ann_return": ann_return,
        "ann_vol": ann_vol,
        "sharpe": sharpe,
    }


def main() -> None:
    # Log the current session to SQLite
    log_usage()

    st.title("Fintech Risk Mini‑App")
    st.write(
        "Analyze a simple moving average (SMA) crossover strategy. "
        "Enter a ticker symbol below to fetch price data, compute SMA signals, and see performance metrics."
    )

    ticker = st.text_input("Ticker symbol (e.g. BTC‑USD, SPY, AAPL)", "BTC-USD")

    # Download data
    data = download_data(ticker)
    if data.empty:
        st.warning("No data returned for that symbol.  Please check the ticker and try again.")
        return

    prices = data["Close"]

    # Compute signals and performance
    signals = compute_sma_signals(prices)
    returns = prices.pct_change().fillna(0)
    perf = compute_performance(returns, signals["Signal"])

    # Display performance stats
    st.subheader("Strategy Performance")
    st.write(f"Annualized Return: **{perf['ann_return']:.2%}**")
    st.write(f"Annualized Volatility: **{perf['ann_vol']:.2%}**")
    st.write(f"Sharpe Ratio: **{perf['sharpe']:.2f}**")

    # Charts
    st.subheader("Price and Moving Averages")
    chart_df = pd.DataFrame({"Price": prices, "Short MA": signals["Short"], "Long MA": signals["Long"]})
    st.line_chart(chart_df)

    st.subheader("Trading Signal (Long = 1, Flat = 0)")
    st.line_chart(signals["Signal"])


if __name__ == "__main__":
    main()
